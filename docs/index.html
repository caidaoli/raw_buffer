<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/strict.dtd">
<html>
<head>
<META http-equiv=Content-Type content="text/html; charset=UTF-8">
<title>Exported from Notepad++</title>
<style type="text/css">
span {
	font-family: 'Courier New';
	font-size: 10pt;
	color: #000000;
}
.sc0 {
}
.sc2 {
	color: #008000;
}
.sc3 {
	color: #008080;
}
.sc4 {
	color: #FF8000;
}
.sc5 {
	font-weight: bold;
	color: #0000FF;
}
.sc6 {
	color: #808080;
}
.sc9 {
	color: #804000;
}
.sc10 {
	font-weight: bold;
	color: #000080;
}
.sc11 {
}
.sc16 {
	color: #8000FF;
}
</style>
</head>
<body>
<div style="float: left; white-space: pre; line-height: 1; background: #FFFFFF; "><span class="sc0">
</span><span class="sc9">#include "rawbuffer.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;assert.h&gt;
</span><span class="sc5">using</span><span class="sc0"> </span><span class="sc5">namespace</span><span class="sc0"> </span><span class="sc11">std</span><span class="sc10">;</span><span class="sc0">

</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">mystruct0</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">xx</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">short</span><span class="sc0"> </span><span class="sc11">yy</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">zz</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">};</span><span class="sc2">//Yes, we support raw struct packed in raw buffer, if all the numeric member is portable!
</span><span class="sc0">  </span><span class="sc2">//是的，我们支持原生的结构体，只要里面的数值类型都是可移植的。推荐使用int32_t, int16_t这样更有可移植性的类型。
</span><span class="sc0">
</span><span class="sc2">//Do not use multiple inheritance. It will leads to several unportable layouts between several compilers.
//别使用多继承。会在各个编译器之间产生很多无法移植的内存布局。
</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">mystruct1</span><span class="sc10">:</span><span class="sc0"> </span><span class="sc16">public</span><span class="sc0"> </span><span class="sc11">mystruct0</span><span class="sc10">{</span><span class="sc0"> 
</span><span class="sc10">};</span><span class="sc0">

</span><span class="sc2">//overload &lt;&lt; operator to enable output of mystruct0.
//重载一下&lt;&lt; 操作符让mystruct0支持输出到流
</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">ostream</span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc5">operator</span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">ostream</span><span class="sc0"> </span><span class="sc10">&amp;</span><span class="sc11">ost</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc11">mystruct0</span><span class="sc10">&amp;</span><span class="sc0"> </span><span class="sc11">rhs</span><span class="sc10">){</span><span class="sc0">
    </span><span class="sc11">ost</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"xx="</span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">rhs</span><span class="sc10">.</span><span class="sc11">xx</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"  "</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"yy="</span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">rhs</span><span class="sc10">.</span><span class="sc11">yy</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"  "</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"zz="</span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">rhs</span><span class="sc10">.</span><span class="sc11">zz</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc11">ost</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">

</span><span class="sc2">//Yes, we can use the packet data type that defined later as fields.
//是的，我们还可以使用延迟定义的包数据类型作为包的数据成员。
</span><span class="sc16">struct</span><span class="sc0"> </span><span class="sc11">test_type1</span><span class="sc10">;</span><span class="sc0">


</span><span class="sc2">//Between DEF_PACKET_BEGIN and DEF_PACKET_END are the data fields. test_type is the packet type name
//在DEF_PACKET_BEGIN 和 DEF_PACKET_END之间的是包的数据成员。test_type是包的类型名字
</span><span class="sc11">DEF_PACKET_BEGIN</span><span class="sc10">(</span><span class="sc11">test_type</span><span class="sc10">)</span><span class="sc0"> 
    
    </span><span class="sc11">ADD_FIELD_REQUIRED</span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">a</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc2">//ADD_FIELD_REQUIRED will layout the field "a" like a c struct member "int a" 
</span><span class="sc0">    </span><span class="sc2">//ADD_FIELD_REQUIRED 会把a当C结构体的整数成员一样进行布局和存储
</span><span class="sc0">    </span><span class="sc2">//So the packet in raw_buffer is a tree struct and the required fields are value of the tree node.
</span><span class="sc0">    </span><span class="sc2">//所以在raw_buffer中包是一个树形的结构体，必须的字段会被视为树的节点的值。
</span><span class="sc0">

    </span><span class="sc2">//The rest fields are optional. They are son node of the current packet
</span><span class="sc0">    </span><span class="sc2">//剩下的都是可选的字段. 他们是当前包的子节点。
</span><span class="sc0">    </span><span class="sc11">ADD_FIELD</span><span class="sc10">(</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">x</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">ADD_FIELD</span><span class="sc10">(</span><span class="sc16">long</span><span class="sc0"> </span><span class="sc16">long</span><span class="sc0"> </span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">y</span><span class="sc10">)</span><span class="sc0">    </span><span class="sc2">// do not use 64bit integer as required field,their alignment is not portable
</span><span class="sc0">    
    </span><span class="sc11">ADD_FIELD</span><span class="sc10">(</span><span class="sc11">mystruct0</span><span class="sc0"> </span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">z</span><span class="sc10">)</span><span class="sc0">           
    </span><span class="sc11">ADD_FIELD</span><span class="sc10">(</span><span class="sc11">mystruct1</span><span class="sc0"> </span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">w</span><span class="sc10">)</span><span class="sc0">        

    </span><span class="sc2">//"ANY" field definition can be used for any other packet type that even only declared.
</span><span class="sc0">    </span><span class="sc2">//"ANY" 式的成员定义可以用于任何其他仅仅有声明的包类型。
</span><span class="sc0">
    </span><span class="sc2">//test_type1 need to be defined by DEF_PACKET_BEGIN when test_type is used in your codes and test_type1 must be another packet type!
</span><span class="sc0">    </span><span class="sc2">//当你开始使用test_type的时候，test_type1需要已被定义并且他必须也是通过DEF_PACKET_BEGIN定义的数据包类型。
</span><span class="sc0">    </span><span class="sc11">ADD_PACKET_ANY</span><span class="sc10">(</span><span class="sc11">test_type1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">u</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc2">//test_type1 need to be defined by DEF_PACKET_BEGIN when test_type is used in your codes and test_type1 must be another packet type!
</span><span class="sc0">    </span><span class="sc2">//当你开始使用test_type的时候，test_type1需要已被定义并且他必须也是通过DEF_PACKET_BEGIN定义的数据包类型。
</span><span class="sc0">    </span><span class="sc11">ADD_PACKET_ARRAY_ANY</span><span class="sc10">(</span><span class="sc11">test_type1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">v</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc2">//After protocol is published, we can only modify it safely by adding or removing optional fields at the back of the packet.
</span><span class="sc0">    </span><span class="sc2">//协议公开之后，对协议安全的修改只允许在协议末尾增加或者删除字段。
</span><span class="sc11">DEF_PACKET_END</span><span class="sc10">(</span><span class="sc11">test_type</span><span class="sc10">)</span><span class="sc0">


</span><span class="sc2">//Now lets turn to a harder one: test_type1
//好，现在我们来点复杂的协议: test_type1。
</span><span class="sc11">DEF_PACKET_BEGIN</span><span class="sc10">(</span><span class="sc11">test_type1</span><span class="sc10">)</span><span class="sc0">
    
    </span><span class="sc2">//All the optional fields will be visited via their offset stored in the packet. The default offset type is uint32_t
</span><span class="sc0">    </span><span class="sc2">//Our packet test_type1 here will not be bigger than 1&lt;&lt;16 in design of users. So we can use a smaller unsigned type instead to save space.
</span><span class="sc0">    </span><span class="sc2">//所有的可选成员，都会通过在包中存储的他们的位置偏移量来进行访问。默认偏移量类型是uint32_t.
</span><span class="sc0">    </span><span class="sc2">//这里我们的数据包test_type1按照使用者的设计，不会超过1&lt;&lt;16, 所以可以使用一个小一点的无符号数值类型来节省空间。
</span><span class="sc0">    </span><span class="sc5">typedef</span><span class="sc0"> </span><span class="sc16">unsigned</span><span class="sc0"> </span><span class="sc16">short</span><span class="sc0"> </span><span class="sc11">offset_type</span><span class="sc10">;</span><span class="sc0">
    
    </span><span class="sc2">//We can define a fixed length array field like: char aa[12];
</span><span class="sc0">    </span><span class="sc2">//我们可以定义一个定长的数组成员：char aa[12];
</span><span class="sc0">    </span><span class="sc11">ADD_FIELD_ARRAY_REQUIRED</span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">aa</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">12</span><span class="sc10">)</span><span class="sc0">
    
    </span><span class="sc2">//Ok, next! 
</span><span class="sc0">    </span><span class="sc2">//好的，再来一个
</span><span class="sc0">    </span><span class="sc11">ADD_FIELD_ARRAY_REQUIRED</span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">bb</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">)</span><span class="sc0">
    
    </span><span class="sc2">//We can define an optioanl variable length vector field. 
</span><span class="sc0">    </span><span class="sc2">//我们也可以定义一个变长的可选的数组成员。注意32仅仅是个长度估计，用来初始化时评估预分配内存数量的，不会限制cc的大小，可以安全的随意修改。
</span><span class="sc0">    </span><span class="sc11">ADD_FIELD_ARRAY</span><span class="sc10">(</span><span class="sc16">int</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">cc</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">32</span><span class="sc10">)</span><span class="sc0">    
    </span><span class="sc2">//Here 32 just provides an estimation of ccfor the writer pre-allocation. It does not limit the size of cc.
</span><span class="sc0">    </span><span class="sc2">//32 can be changed into other number after the protocol is published because it just affect the meory allocator.
</span><span class="sc0">      
    </span><span class="sc2">//We can define a knownable packet as field. For safety it can not be required!
</span><span class="sc0">    </span><span class="sc2">//我们还可以定义一个已知的包类型作为数据成员。为了安全（包类型可能增减成员），他不可以被声明为必须的。
</span><span class="sc0">    </span><span class="sc11">ADD_PACKET</span><span class="sc10">(</span><span class="sc11">test_type</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">xx</span><span class="sc10">)</span><span class="sc0">
    
    </span><span class="sc2">//just more fields..
</span><span class="sc0">    </span><span class="sc2">//再来更多的数据成员
</span><span class="sc0">    </span><span class="sc11">ADD_FIELD</span><span class="sc10">(</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">yy</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">ADD_FIELD_ARRAY</span><span class="sc10">(</span><span class="sc16">char</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">zz</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">32</span><span class="sc10">)</span><span class="sc0">
    </span><span class="sc11">ADD_PACKET</span><span class="sc10">(</span><span class="sc11">test_type</span><span class="sc0"> </span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ww</span><span class="sc10">)</span><span class="sc0">
    
    </span><span class="sc2">//We can define a optioanl variable length vector of knownable packet as field. For safety it can not be required!
</span><span class="sc0">    </span><span class="sc2">//我们还可以定义一个已知的包类型的变长数组作为数据成员。为了安全（包类型可能增减成员），他不可以被声明为必须的。
</span><span class="sc0">    </span><span class="sc11">ADD_PACKET_ARRAY</span><span class="sc10">(</span><span class="sc11">test_type</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">uu</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">)</span><span class="sc0">

    </span><span class="sc11">ADD_PACKET_ARRAY</span><span class="sc10">(</span><span class="sc11">test_type</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">tt</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">)</span><span class="sc0">

    </span><span class="sc2">//test_type1 can use the packet type itself, make a link list.
</span><span class="sc0">    </span><span class="sc2">//test_type1 还可以使用自己类型,可以构造出链表效果。
</span><span class="sc0">    </span><span class="sc11">ADD_PACKET_ANY</span><span class="sc10">(</span><span class="sc11">test_type1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">vv</span><span class="sc10">)</span><span class="sc0">

    </span><span class="sc2">//test_type1 can use the packet type itself as array, make a tree.
</span><span class="sc0">    </span><span class="sc2">//test_type1 还可以使用自己类型做数组,可以构造出树的效果。
</span><span class="sc0">    </span><span class="sc11">ADD_PACKET_ARRAY_ANY</span><span class="sc10">(</span><span class="sc11">test_type1</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">dd</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">)</span><span class="sc0">

    </span><span class="sc2">//After protocol is published, we can only modify it safely by adding or removing optional fields at the back of the packet.
</span><span class="sc0">    </span><span class="sc2">//Or update the size estimation of the optional array of cc, zz, uu.
</span><span class="sc0">    </span><span class="sc2">//协议公开之后，对协议安全的修改只允许在协议末尾增加或者删除字段。或者修改对可选数组如cc,zz,uu,dd的长度估计。
</span><span class="sc0">      
</span><span class="sc11">DEF_PACKET_END</span><span class="sc10">(</span><span class="sc11">test_type1</span><span class="sc10">)</span><span class="sc0">

</span><span class="sc9">#define OUTPUT_TEST(x) std::cout &lt;&lt;"Line " RAW_BUF_STRING(__LINE__) ": " RAW_BUF_STRING(x) &lt;&lt; std::endl; x; std::cout &lt;&lt; std::endl
</span><span class="sc0">
</span><span class="sc2">//Now let us use our protocol
//好，我们来试试我们定义的协议。
</span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">main</span><span class="sc10">(){</span><span class="sc0">
    </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">boolalpha</span><span class="sc0"> </span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">//If the packet test_type can be a tree, rawbuf_builder&lt;test_type&gt; is use to pre-allocate the tree and build the root node of the tree. Rellocation may happen if your optional array is assigned with size greater than its estimation in protocol.
</span><span class="sc0">    </span><span class="sc2">//如果把包test_type看成一个数据包树，那么rawbuf_builder&lt;test_type&gt;就是用来初始化分配树的内存开销和构造这颗树的根的。如果可选的变长数组被赋值的长度超过了协议中的估计，那么可能会发生reallocation.
</span><span class="sc0">    </span><span class="sc11">rawbuf_builder</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">instance</span><span class="sc10">;</span><span class="sc0">     
    
    </span><span class="sc2">//builder can be used as a smart pointer. Fields name is the function name for assignment.
</span><span class="sc0">    </span><span class="sc2">//builder可以当成智能指针来用。数据成员名字则被当成函数名字用来进行赋值。
</span><span class="sc0">    </span><span class="sc11">instance</span><span class="sc10">-&gt;</span><span class="sc11">x</span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">);</span><span class="sc0">                 
    </span><span class="sc11">instance</span><span class="sc10">-&gt;</span><span class="sc11">y</span><span class="sc10">(</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">instance</span><span class="sc10">-&gt;</span><span class="sc11">a</span><span class="sc10">(</span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">
    
     </span><span class="sc2">//() operator always results a raw pointer(of test_type), required fields can assigend via the raw pointer and a little quicker（can be ignored in fact）
</span><span class="sc0">     </span><span class="sc2">//()操作符会返回一个原生的（test_type）指针，必须的字段可以通过原生指针进行赋值, 会快一点点（简直可以忽略）
</span><span class="sc0">    </span><span class="sc11">instance</span><span class="sc10">()-&gt;</span><span class="sc11">a</span><span class="sc10">(</span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
                                    
    </span><span class="sc11">mystruct1</span><span class="sc0"> </span><span class="sc11">t1</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">t1</span><span class="sc10">.</span><span class="sc11">xx</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">t1</span><span class="sc10">.</span><span class="sc11">yy</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">3</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">t1</span><span class="sc10">.</span><span class="sc11">zz</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">instance</span><span class="sc10">-&gt;</span><span class="sc11">z</span><span class="sc10">(</span><span class="sc11">t1</span><span class="sc10">);</span><span class="sc0">
    
    </span><span class="sc2">//output function is only available for the raw pointer. The output is in json style. Char array will be output as c-string with proper escape.
</span><span class="sc0">    </span><span class="sc2">//output函数只能通过原生指针来调用。输出是json格式的。char数组会自动当字符串来打印，并且会进行适当的转义。
</span><span class="sc0">    </span><span class="sc11">instance</span><span class="sc10">()-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">//We will use the following function to tag each output;
</span><span class="sc0">    </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">instance</span><span class="sc10">()-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">
    
    </span><span class="sc11">test_type</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pinstance</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">instance</span><span class="sc10">();</span><span class="sc0">
    
    </span><span class="sc2">//Fields name is also the data visiting function name. It will return the data 地址.
</span><span class="sc0">    </span><span class="sc2">//数据成员的名字也是数据访问的函数名字, 会返回数据成员的地址。
</span><span class="sc0">    </span><span class="sc11">pinstance</span><span class="sc10">-&gt;</span><span class="sc11">z</span><span class="sc10">()-&gt;</span><span class="sc11">xx</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0"> 
    </span><span class="sc11">pinstance</span><span class="sc10">-&gt;</span><span class="sc11">z</span><span class="sc10">()-&gt;</span><span class="sc11">yy</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">4</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">pinstance</span><span class="sc10">-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc2">//Harder usage
</span><span class="sc0">    </span><span class="sc2">//更复杂的用法
</span><span class="sc0">    </span><span class="sc11">rawbuf_builder</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">;</span><span class="sc0">

    </span><span class="sc2">//Every packet nodes in the packet tree can be created by assignment or alloc like following (for deeper assignment)
</span><span class="sc0">    </span><span class="sc2">//数据包树里的每一个非根节点可以通过上面的赋值或者像下面这样分配来进行创建(然后再进一步的对子成员赋值)
</span><span class="sc0">    </span><span class="sc11">rawbuf_writer</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">packet</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">xx</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">alloc</span><span class="sc10">&gt;();</span><span class="sc0">
    </span><span class="sc2">//rawbuf_writer is the base class of rawbuf_builder, which provides the data assignment and visiting function shown above.
</span><span class="sc0">    </span><span class="sc2">//rawbuf_writer 是rawbuf_builder的基类，提供了前面所展示的所有数据访问和赋值功能。
</span><span class="sc0">
    </span><span class="sc11">packet</span><span class="sc10">-&gt;</span><span class="sc11">x</span><span class="sc10">(</span><span class="sc4">5</span><span class="sc10">);</span><span class="sc0">                                   
    </span><span class="sc11">packet</span><span class="sc10">-&gt;</span><span class="sc11">w</span><span class="sc10">(</span><span class="sc11">t1</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">yy</span><span class="sc10">(</span><span class="sc4">6</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">aa</span><span class="sc10">(</span><span class="sc6">"Sorry!"</span><span class="sc10">);</span><span class="sc0">            </span><span class="sc2">//We support array direct assignment!
</span><span class="sc0">    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">aa</span><span class="sc10">(</span><span class="sc6">"Sorry!"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">);</span><span class="sc0">         </span><span class="sc2">//Same effection...
</span><span class="sc0">
    </span><span class="sc11">memcpy</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">aa</span><span class="sc10">(),</span><span class="sc0"> </span><span class="sc6">"Sorry!"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">7</span><span class="sc10">);</span><span class="sc0">     </span><span class="sc2">//It is safe as the size of aa is 12.
</span><span class="sc0">    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">zz</span><span class="sc10">(</span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc11">tester</span><span class="sc10">[]</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">{</span><span class="sc4">4</span><span class="sc10">,</span><span class="sc4">5</span><span class="sc10">};</span><span class="sc0">
    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">bb</span><span class="sc10">(</span><span class="sc11">tester</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">       </span><span class="sc2">//The length of bb is still 3(the length of the required array is always fixed!), but we modify its first and second value.
</span><span class="sc0">    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">cc</span><span class="sc10">(</span><span class="sc11">tester</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">       </span><span class="sc2">//The length of cc is 2(the length of the optional array is depending on the assignment!).
</span><span class="sc0">
    </span><span class="sc2">//The writer can not used for reading. You can use () to cast it to raw pointer to visit address of assigned field, like instance2()-&gt;bb().
</span><span class="sc0">    </span><span class="sc2">//instance2() return a test_type1 pointer and -&gt;bb() return its the address of field bb
</span><span class="sc0">    </span><span class="sc2">//However the pointers may become invalid after further assginment of the owned builder or writer due to reallocation. 
</span><span class="sc0">    </span><span class="sc2">//So take care when using the raw pointer from writer.
</span><span class="sc0">    </span><span class="sc2">//writer是不能用来读取数据的. 所以得使用()来转换成原生指针来访问yy。()-&gt;可以看成一个操作符嘛^_^
</span><span class="sc0">    </span><span class="sc2">//instance2()返回一个test_type1指针，-&gt;bb()返回他的成员bb的地址。
</span><span class="sc0">    </span><span class="sc2">//但是这些原生指针可能在被所属的writer或者builder进一步的赋值中因为reallocation失效，所以谨慎使用从writer中获取的指针。
</span><span class="sc0">
    
    </span><span class="sc2">//Let us start with a usual mistake.
</span><span class="sc0">    </span><span class="sc2">//std::vecotr&lt;int&gt; x; x.push_back(4);x.push_back(4);x.push_back(4);x.push_back(4);
</span><span class="sc0">    </span><span class="sc2">//x.push_back(*x.begin());  WARNING! ERROR CODES!
</span><span class="sc0">
    </span><span class="sc2">//Error codes: because push_back may lead to reallocation and make the argument of push_back invalid.
</span><span class="sc0">    </span><span class="sc2">//错误的代码: 因为push_back可能导致reallocation然后让push_back的参数是个无效的引用
</span><span class="sc0">
    </span><span class="sc2">//So do not copy the field to another one in the same root builder until you guarantee it will not reallocate during the copy!
</span><span class="sc0">    </span><span class="sc2">//所以除非你能保证拷贝时不会发生缓冲区重新分配, 否则不要把已有的数据成员拷贝到同一个根builder的其它数据成员上。
</span><span class="sc0">    
    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">bb</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">yy</span><span class="sc10">(),</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">        
    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">cc</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">bb</span><span class="sc10">(),</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc2">//Is the above codes safe? In fact raw_buffer has tried best to avoid reallocation. The defualt initial builder capacity can afford
</span><span class="sc0">    </span><span class="sc2">//all the required and "non-any" optional fields size (size of optional array data based on the size_estimation arguments) and
</span><span class="sc0">    </span><span class="sc2">//worst assignment order and alignment cost.
</span><span class="sc0">    </span><span class="sc2">//Reallocation can and only can happen after following cases appear (may not immediately, it may reallocate at anytime of future assignment):
</span><span class="sc0">    </span><span class="sc2">//0: your builder is constructed with your own capacity, not default.
</span><span class="sc0">    </span><span class="sc2">//1: you assign an optional array field with size greater than its size_estimation arguments in defination.
</span><span class="sc0">    </span><span class="sc2">//2: you assign an optional array field with size B, then assign it again with greater size B+(even B+ is less than the size estimation).
</span><span class="sc0">    </span><span class="sc2">//3. you assign an "any" packet (or array) field. Size of "any" fields is not including in the initial builder capacity.
</span><span class="sc0">    </span><span class="sc2">//4. you assign a packet or array field,indirectly leading to case  1, 2, 3
</span><span class="sc0">    </span><span class="sc2">//So the two assignment of the above codes are safe becase we do not have the above 5 behaviours till now.
</span><span class="sc0">    </span><span class="sc2">//
</span><span class="sc0">    </span><span class="sc2">//上面的代码安全吗？其实raw_buffer已经竭尽全力去避免reallocation. 默认的builder初始化容量能够装的下所有的必须和可选字段（
</span><span class="sc0">    </span><span class="sc2">//可选数组字段的大小是根据他在定义中的size_estimation参数），能够承受最坏的赋值顺序所导致的对齐开销。
</span><span class="sc0">    </span><span class="sc2">//reallocation可能也只可能在如下场景发生后发生（不一定立即发生，在此之后的任何赋值场景随时可能reallocation）：
</span><span class="sc0">    </span><span class="sc2">//0: 你构造builder时使用了自定义的初始容量值。
</span><span class="sc0">    </span><span class="sc2">//1: 你给一个可选数组字段，赋值的长度超过了他在定义时的长度估计。
</span><span class="sc0">    </span><span class="sc2">//2: 你给一个可选数组字段赋值，赋值的长度为B, 然后接下来又给他重新赋值了一个长点的长度B+(即使B+比定义的长度估计小)。
</span><span class="sc0">    </span><span class="sc2">//3: 你给一个"any"类型字段赋值。any"类型字段的大小是没有在builder的初始容量中进行计算的。
</span><span class="sc0">    </span><span class="sc2">//4: 你给一个packet或者packet array赋值时，间接导致了1，2，3
</span><span class="sc0">    </span><span class="sc2">//所以上面那2行赋值代码是安全的，因为距今为止我们没有上面提到的5种行为。
</span><span class="sc0">
    </span><span class="sc2">//But we can use "reference" instead of "copy" for optional field from another to avoid any possible rellocation.
</span><span class="sc0">    </span><span class="sc2">//You can use a field A "reference" another field B only if
</span><span class="sc0">    </span><span class="sc2">//0.they come from the same root builder.
</span><span class="sc0">    </span><span class="sc2">//1.the parent field of A is allocated or assigned ealier than B.
</span><span class="sc0">    </span><span class="sc2">//2.violation of the above two ruls leads to reference failed.
</span><span class="sc0">    </span><span class="sc2">//但是我们可以让一个成员“引用”另一个成员而不是“拷贝”来避免任何可能的reallocation.
</span><span class="sc0">    </span><span class="sc2">//仅当以下条件成立时可以让成员A引用成员B：
</span><span class="sc0">    </span><span class="sc2">//0.他们来自同一个根builder；
</span><span class="sc0">    </span><span class="sc2">//1.A的父节点比B更早分配或赋值；
</span><span class="sc0">    </span><span class="sc2">//2.对以上2点的违反将会导致引用失败。
</span><span class="sc0">    </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">yy</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">add_ref</span><span class="sc10">&gt;(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">bb</span><span class="sc10">())){</span><span class="sc0"> 
        </span><span class="sc2">//Parent node of yy is instance2 and bb is required field of instance2(so bb is allocated as soon as instance2)
</span><span class="sc0">        </span><span class="sc2">//So it disobeys  rule 1.
</span><span class="sc0">        </span><span class="sc2">//yy的父节点是instance2 而 bb是instance2的必须字段（所以bb和instance2一起进行分配）
</span><span class="sc0">        </span><span class="sc2">//所以这违背了规则1
</span><span class="sc0">        </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"Add reference must failed!"</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">yy</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">add_ref</span><span class="sc10">&gt;(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">cc</span><span class="sc10">())){</span><span class="sc0">  
        </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"Add reference must succeed!"</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc2">//Now we create packet node ww directly via assignment.
</span><span class="sc0">    </span><span class="sc2">//* operator return the reference of the raw pointer
</span><span class="sc0">    </span><span class="sc2">//现在我们通过赋值来创建非根节点ww
</span><span class="sc0">    </span><span class="sc2">//* 操作符返回原生指针的引用。
</span><span class="sc0">    </span><span class="sc11">packet</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">ww</span><span class="sc10">(*</span><span class="sc11">instance</span><span class="sc10">);</span><span class="sc0">  </span><span class="sc2">//*instance == *(instance())
</span><span class="sc0">    </span><span class="sc11">packet</span><span class="sc10">-&gt;</span><span class="sc11">w</span><span class="sc10">(</span><span class="sc11">t1</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">zz</span><span class="sc10">(</span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0">
                  </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0">
                  </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0">
                  </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0">
                  </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0">
                  </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0">
                  </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0"> </span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc0">
                  </span><span class="sc10">);</span><span class="sc0"> 
    </span><span class="sc2">//This assignment size is far beyond the size estimation of zz defined in protocol and it may lead to reallocation of instance2. But every writer like "packet" is safe.
</span><span class="sc0">    </span><span class="sc2">//这个赋值已经大大超过了zz在协议中定义时的长度估计, 这可能会导致instance2的重新分配空间。所有的现存的rawbuf_writer，像"packet"依然是安全的。
</span><span class="sc0">
    </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">
    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">zz</span><span class="sc10">(</span><span class="sc6">"I say :\"Hello \\ world!\""</span><span class="sc10">);</span><span class="sc0"> 

    </span><span class="sc2">//From now on, reallocation of instance2 may happen at anytime. Be careful of using the address of the assigned fields of instance2.
</span><span class="sc0">    </span><span class="sc2">//从现在起，reallocation 随时可能发生在instance2身上。谨慎使用instance2上以赋值的成员的地址。
</span><span class="sc0">
    </span><span class="sc2">//Copy the packet itself to its field will lead infinite recursion and relocation and crash at last.
</span><span class="sc0">    </span><span class="sc2">//把自己拷贝到自己的的成员上会导致无限循环,最终导致relocation而让输入参数无效。
</span><span class="sc0">    </span><span class="sc2">//instance2.reserve(instance2.size()*8);     //No matter how much the capcity is, it will be exhausted
</span><span class="sc0">    </span><span class="sc2">//instance2-&gt;vv(*instance2);                // And *instance2 must be an invalid reference finally.
</span><span class="sc0">
    </span><span class="sc2">//So we need to copy to other builder first.
</span><span class="sc0">    </span><span class="sc11">rawbuf_builder</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">instance3</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">instance3</span><span class="sc10">-&gt;</span><span class="sc11">copy</span><span class="sc10">(*</span><span class="sc11">instance2</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">vv</span><span class="sc10">(*</span><span class="sc11">instance3</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc2">//Now we try re-assignment the packet node.
</span><span class="sc0">    </span><span class="sc2">//现在我们来试试对已经赋值的节点重新赋值
</span><span class="sc0">    </span><span class="sc11">packet</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">ww</span><span class="sc10">(*</span><span class="sc11">instance</span><span class="sc10">);</span><span class="sc0">  
    </span><span class="sc2">//instance2()-&gt;ww()-&gt;w() becomes null (as instance()-&gt;w() is null) and the memory previously used (in "packet-&gt;w(t1);" ) 
</span><span class="sc0">    </span><span class="sc2">//is waste as that memory becomes a "memory fragment" and for time efficiency, we will not try to reuse it. 
</span><span class="sc0">    </span><span class="sc2">//So be careful for using re-assignment for all optional fields!
</span><span class="sc0">    </span><span class="sc2">//instance2的ww字段的w字段现在变成了空，而且刚才w占据的空间出于时间效率会被浪费掉了而不会被重用。所以谨慎使用对可选成员重新赋值这个功能。
</span><span class="sc0">     
    </span><span class="sc2">//The allocation or assignment of the packet array will return a rawbuf_writer_iterator, a sub-class of rawbuf_writer at the begin element.
</span><span class="sc0">    </span><span class="sc2">//It supports the increament, [] or other pointer "shifting" operation. It becomes like a real pointer.
</span><span class="sc0">    </span><span class="sc2">//对于包的数组的赋值或者分配会返回一个rawbuf_writer_iterator，他是rawbuf_writer的子类并位于数组第一个元素。
</span><span class="sc0">    </span><span class="sc2">//他支持自增，[]下标操作或者其它移动操作。他变得像一个真正的指针了。
</span><span class="sc0">    </span><span class="sc11">rawbuf_writer_iterator</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">it</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">uu</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">alloc</span><span class="sc10">&gt;(</span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">it</span><span class="sc10">-&gt;</span><span class="sc11">x</span><span class="sc10">(</span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">++</span><span class="sc11">it</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">it</span><span class="sc10">-&gt;</span><span class="sc11">x</span><span class="sc10">(</span><span class="sc4">4</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">it</span><span class="sc10">[</span><span class="sc11">size_t</span><span class="sc10">(-</span><span class="sc4">1</span><span class="sc10">)]-&gt;</span><span class="sc11">a</span><span class="sc10">(</span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">(</span><span class="sc11">it</span><span class="sc10">-=</span><span class="sc4">1</span><span class="sc10">)-&gt;</span><span class="sc11">y</span><span class="sc10">(</span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">(</span><span class="sc11">it</span><span class="sc10">++)-&gt;</span><span class="sc11">y</span><span class="sc10">(</span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">(</span><span class="sc11">it</span><span class="sc10">--)-&gt;</span><span class="sc11">a</span><span class="sc10">(</span><span class="sc4">3</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc2">//(it+1)-&gt;a(2);  it is not supported because we have supported cast it to bool type, so it will lead to ambigious warning in GCC.
</span><span class="sc0">
    </span><span class="sc2">//Even you use raw pointer to visit, you also get an iterator to iterate the packet array.
</span><span class="sc0">    </span><span class="sc2">//Becuase the content pointed by raw data maybe from outer data and its packet element may have different sizeof(test_type).
</span><span class="sc0">    </span><span class="sc2">//Using ()operator to get raw pointer
</span><span class="sc0">    </span><span class="sc2">//即使你使用原始指针来访问uu, 你依然只能得到一个遍历器来遍历。
</span><span class="sc0">    </span><span class="sc2">//因为可能原始指针执行的内容是来自外部数据，里面的包数组元素可能有不同的可选字段数量导致大小和我们的sizeof(test_type)有所不同
</span><span class="sc0">    </span><span class="sc2">//使用()操作符来获取原始指针
</span><span class="sc0">    </span><span class="sc11">rawbuf_packet_iterator</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">iti</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">uu</span><span class="sc10">();</span><span class="sc0">
    </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">iti</span><span class="sc10">-&gt;</span><span class="sc11">a</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">iti</span><span class="sc10">()-&gt;</span><span class="sc11">a</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">


    

    </span><span class="sc2">//it also can be assigned by other.
</span><span class="sc0">    </span><span class="sc11">rawbuf_writer_iterator</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">itt</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">tt</span><span class="sc10">(</span><span class="sc11">instance</span><span class="sc10">(),</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc0">
        </span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">itt</span><span class="sc10">-&gt;</span><span class="sc11">a</span><span class="sc10">(-</span><span class="sc4">1</span><span class="sc10">);</span><span class="sc0">

    </span><span class="sc2">//Now we will exam the "any" type field whether they are the same as "non-any" type
</span><span class="sc0">    </span><span class="sc2">//现在我们检查下ANY类型的成员是否和非ANY类型的使用完全相同
</span><span class="sc0">    </span><span class="sc11">rawbuf_writer_iterator</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">itd</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">-&gt;</span><span class="sc11">dd</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">alloc</span><span class="sc10">&gt;(</span><span class="sc4">2</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc10">++</span><span class="sc11">itd</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">itt</span><span class="sc10">-&gt;</span><span class="sc11">v</span><span class="sc10">(</span><span class="sc11">instance3</span><span class="sc10">(),</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)-&gt;</span><span class="sc11">xx</span><span class="sc10">(*</span><span class="sc11">instance</span><span class="sc10">)-&gt;</span><span class="sc11">v</span><span class="sc10">(</span><span class="sc11">instance3</span><span class="sc10">(),</span><span class="sc0"> </span><span class="sc4">1</span><span class="sc10">)-&gt;</span><span class="sc11">xx</span><span class="sc10">(*</span><span class="sc11">instance</span><span class="sc10">);</span><span class="sc0"> </span><span class="sc2">//Amazing!
</span><span class="sc0">    
    
    </span><span class="sc2">//The only difference is when we visit the packet "any" type, we need to mention its type. 
</span><span class="sc0">    </span><span class="sc2">//This is the cost of supporting C++03..
</span><span class="sc0">    </span><span class="sc2">//有唯一一点不同：访问包数组时，any类型需要指明元素类型。
</span><span class="sc0">    </span><span class="sc2">//这是兼容C++03的代价。
</span><span class="sc0">    </span><span class="sc11">itt</span><span class="sc10">()-&gt;</span><span class="sc11">v</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">&gt;();</span><span class="sc0"> 
    </span><span class="sc11">itd</span><span class="sc10">-&gt;</span><span class="sc11">vv</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">add_ref</span><span class="sc10">&gt;(</span><span class="sc11">itt</span><span class="sc10">()-&gt;</span><span class="sc11">v</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">&gt;()());</span><span class="sc0">

    </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">()-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">

    </span><span class="sc2">//Now we write the date to file
</span><span class="sc0">    </span><span class="sc2">//现在我们把数据写到文件里去
</span><span class="sc0">    </span><span class="sc9">#ifndef PORT_TEST
</span><span class="sc0">    </span><span class="sc10">{</span><span class="sc0">
        </span><span class="sc11">ofstream</span><span class="sc0"> </span><span class="sc11">test_out</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc11">test_out</span><span class="sc10">.</span><span class="sc11">open</span><span class="sc10">(</span><span class="sc6">"./test.data"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ios_base</span><span class="sc10">::</span><span class="sc11">binary</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc11">ios_base</span><span class="sc10">::</span><span class="sc11">out</span><span class="sc10">);</span><span class="sc0">
        </span><span class="sc2">//data() returns the buffer pointer
</span><span class="sc0">        </span><span class="sc2">//size() returns the buffer size
</span><span class="sc0">        </span><span class="sc11">test_out</span><span class="sc10">.</span><span class="sc11">write</span><span class="sc10">(</span><span class="sc11">instance2</span><span class="sc10">.</span><span class="sc11">data</span><span class="sc10">(),</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">.</span><span class="sc11">size</span><span class="sc10">());</span><span class="sc0">
        </span><span class="sc11">test_out</span><span class="sc10">.</span><span class="sc11">flush</span><span class="sc10">();</span><span class="sc0">
        </span><span class="sc11">test_out</span><span class="sc10">.</span><span class="sc11">close</span><span class="sc10">();</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc9">#endif
</span><span class="sc0">    
    </span><span class="sc3">/***************************************************************
    Now we can talk about the reader from received data
    现在我们谈谈如何从从外部获取的数据中读取包成员
    ***************************************************************/</span><span class="sc0">
    
     </span><span class="sc2">//do not use "char buffer[4096]" such local variable, it may not be properly 8bytes aligned! Only malloc or new gurantee the 8 bytes alignment (the local array of long long buffer[4096] in GCC-x86 system V ABI is still not aligned in 8 bytes but x64 aligned).
</span><span class="sc0">    </span><span class="sc2">//不要使用"char buffer[4096]" 这样的局部变量, 这样的buffer未必已经8字节对齐. 只有malloc或者new可以确保8字节对齐，long long buffer[4096]在x86上gcc遵照system V ABI的实现也是没有8字节对齐的不过x64已经对齐了。
</span><span class="sc0">    </span><span class="sc16">char</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">buffer</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc5">new</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">[</span><span class="sc4">4096</span><span class="sc10">*</span><span class="sc4">12</span><span class="sc10">];</span><span class="sc0">

    </span><span class="sc11">ifstream</span><span class="sc0"> </span><span class="sc11">test_in</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc11">test_in</span><span class="sc10">.</span><span class="sc11">open</span><span class="sc10">(</span><span class="sc6">"./test.data"</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">ios_base</span><span class="sc10">::</span><span class="sc11">binary</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc11">ios_base</span><span class="sc10">::</span><span class="sc11">in</span><span class="sc0"> </span><span class="sc10">|</span><span class="sc0"> </span><span class="sc11">ios_base</span><span class="sc10">::</span><span class="sc11">ate</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">streamoff</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">test_in</span><span class="sc10">.</span><span class="sc11">tellg</span><span class="sc10">();</span><span class="sc0">
    </span><span class="sc11">test_in</span><span class="sc10">.</span><span class="sc11">seekg</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc4">0</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">test_in</span><span class="sc10">.</span><span class="sc11">beg</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">test_in</span><span class="sc10">.</span><span class="sc11">read</span><span class="sc10">(</span><span class="sc11">buffer</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">error_msg</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">rawbuf_has_error</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">&gt;(</span><span class="sc11">buffer</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">);</span><span class="sc0"> 
    </span><span class="sc2">//This will check buffer as test_type1 and recursively check all the offset of the optional fields, whether they are out of buffer or not properly aligned, or the packet array has different optional fields.
</span><span class="sc0">    </span><span class="sc2">//这会把buffer当成数据包test_type1去检查, 并且会递归的检查所有可选字段的偏移量是否有存在超出buffer范围或者没有正确对齐的情况,和包数组中的元素是否不具有相同的可选字段个数等异常情况。
</span><span class="sc0">    
    </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">error_msg</span><span class="sc10">){</span><span class="sc0"> 
        </span><span class="sc2">//Now we can use buffer as a struct if we guarantee the 8 bytes alignment of buffer! Every required fields must exits!
</span><span class="sc0">        </span><span class="sc2">//检查通过！由于我们保证了缓冲区首部的8字节对齐，我们可以把缓冲区当结构体来用了。其中每个必须的字段都肯定是存在的！
</span><span class="sc0">        </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(((</span><span class="sc11">test_type1</span><span class="sc10">*)</span><span class="sc11">buffer</span><span class="sc10">)-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">
        </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">test_type1</span><span class="sc10">*)</span><span class="sc11">buffer</span><span class="sc10">)-&gt;</span><span class="sc11">bb</span><span class="sc10">()[</span><span class="sc4">0</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">

        </span><span class="sc2">//Optional fields may not assigned. We do not have zero length optional array.
</span><span class="sc0">        </span><span class="sc2">//可选字段未必已经赋值.我们不会有0长度的可选数组。
</span><span class="sc0">        </span><span class="sc16">int</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">cc</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">test_type1</span><span class="sc10">*)</span><span class="sc11">buffer</span><span class="sc10">)-&gt;</span><span class="sc11">cc</span><span class="sc10">();</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc10">(</span><span class="sc11">cc</span><span class="sc10">){</span><span class="sc0">
            </span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">array_count_type</span><span class="sc0"> </span><span class="sc11">ccsize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">test_type1</span><span class="sc10">*)</span><span class="sc11">buffer</span><span class="sc10">)-&gt;</span><span class="sc11">cc</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">get_count</span><span class="sc10">&gt;();</span><span class="sc0"> </span><span class="sc10">(</span><span class="sc16">void</span><span class="sc10">)</span><span class="sc11">ccsize</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc11">assert</span><span class="sc10">(</span><span class="sc11">ccsize</span><span class="sc10">);</span><span class="sc0">
            </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">cc</span><span class="sc10">[</span><span class="sc4">0</span><span class="sc10">]</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        
        </span><span class="sc2">//But we do not check whether the char array is ended with '\0'. 
</span><span class="sc0">        </span><span class="sc2">//We do not assert every char array is stored with string.
</span><span class="sc0">        </span><span class="sc2">//Using c_str command for either required or optional fields to visit it safely.
</span><span class="sc0">        </span><span class="sc2">//但是我们并没有检查char数组是否用'\0'来结尾，因为我们并不假设char数组里存的就是字符串。
</span><span class="sc0">        </span><span class="sc2">//我们可以使用c_str命令来安全的访问这些必须的或者可选的字段
</span><span class="sc0">        
        </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">aa</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">test_type1</span><span class="sc10">*)</span><span class="sc11">buffer</span><span class="sc10">)-&gt;</span><span class="sc11">aa</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">c_str</span><span class="sc10">&gt;();</span><span class="sc0">
        </span><span class="sc2">//For required fields, aa == 0 means '\0' is not found in its array(leading a strnlen cost).
</span><span class="sc0">        </span><span class="sc5">if</span><span class="sc10">(</span><span class="sc11">aa</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">){</span><span class="sc0">
            </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">aa</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        
        </span><span class="sc16">const</span><span class="sc0"> </span><span class="sc16">char</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">zz</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">test_type1</span><span class="sc10">*)</span><span class="sc11">buffer</span><span class="sc10">)-&gt;</span><span class="sc11">zz</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">c_str</span><span class="sc10">&gt;();</span><span class="sc0">
        </span><span class="sc2">//For optional fields, zz == 0 means zz was not assigned or not ended with '\0' .
</span><span class="sc0">        </span><span class="sc5">if</span><span class="sc10">(</span><span class="sc11">zz</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">){</span><span class="sc0">
            </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">zz</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        
        </span><span class="sc2">//For packet array, we do not get the array pointer but an iterator because optional fields of packet may change so it is dangerous to use ++ or [] for the array raw with wrong sizeof(test_type).
</span><span class="sc0">        </span><span class="sc2">//对于包数组，我们并无法直接得到数组的地址指针而是一个迭代器，这是因为包的可选字段数量可能会发生变化，所以使用原生指针去做++或者[]操作是危险的，如果基于我们错误的sizeof(test_type)去移动指针。
</span><span class="sc0">        </span><span class="sc11">rawbuf_packet_iterator</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">it</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">test_type1</span><span class="sc10">*)</span><span class="sc11">buffer</span><span class="sc10">)-&gt;</span><span class="sc11">uu</span><span class="sc10">();</span><span class="sc0">
        </span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">array_count_type</span><span class="sc0"> </span><span class="sc11">psize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc10">((</span><span class="sc11">test_type1</span><span class="sc10">*)</span><span class="sc11">buffer</span><span class="sc10">)-&gt;</span><span class="sc11">uu</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">::</span><span class="sc11">get_count</span><span class="sc10">&gt;();</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc10">(</span><span class="sc11">psize</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0">  </span><span class="sc10">){</span><span class="sc0">
            </span><span class="sc5">for</span><span class="sc10">(</span><span class="sc11">size_t</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">&lt;</span><span class="sc11">psize</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc10">++</span><span class="sc11">i</span><span class="sc10">,++</span><span class="sc11">it</span><span class="sc10">){</span><span class="sc0">
                </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">it</span><span class="sc10">-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    
    </span><span class="sc2">//If a packet has so many optional fields and sub-fields but we only use very small number of them, rawbuf_has_error will be expensive.
</span><span class="sc0">    </span><span class="sc2">//For example, a game role may have 1000+ attributes after level 50 but 10 before level 5， while most gamers are junior players(with low level). Then always full check of all the possible optional fields are usually useless.
</span><span class="sc0">    </span><span class="sc2">//So we can check the fields only before we use it. But like jsoncpp, the "check and read" pattern is a little more complicated.
</span><span class="sc0">    </span><span class="sc2">//如果一个包有很多可选字段，但是我们仅仅只用其中很少一部分的话，rawbuf_has_error就显得很昂贵了。
</span><span class="sc0">    </span><span class="sc2">//例如一个游戏角色可能在50级后有1000多个属性，但是在5级前只有10个。并且多数玩家都是新手，等级不高。所以总是全量检查所有可能存在的可选字段就往往不必要了。
</span><span class="sc0">    </span><span class="sc2">//所以我们可以仅仅在我们使用某个字段的时候去检查他。但是类似jsoncpp这种“检查并读”的模式用起来稍微有点复杂。
</span><span class="sc0">    
    </span><span class="sc11">rawbuf_reader</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">reader2</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">reader2</span><span class="sc10">.</span><span class="sc11">init</span><span class="sc10">(</span><span class="sc11">buffer</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">)){</span><span class="sc0">  
        </span><span class="sc2">//Init failed! It just checked the top level validity of test_type1, not including its fields.
</span><span class="sc0">        </span><span class="sc2">//初始化失败了。reader2.init 只会检查test_type1结构体自身的合法性，还不会去检查他的成员。
</span><span class="sc0">        </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">reader2</span><span class="sc10">.</span><span class="sc11">error_msg</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">delete</span><span class="sc0"> </span><span class="sc10">[]</span><span class="sc11">buffer</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    
    </span><span class="sc2">//Each data visiting function of reader will check the data validity. If the data was corrupted, reader will be destroyed to stop you to visit other fields! 
</span><span class="sc0">    </span><span class="sc2">//Data corruption is not local but always global!
</span><span class="sc0">    </span><span class="sc2">//通过reader去访问数据成员会检查数据的合法性，如果发现数据被损坏了，reader会变得不可用来阻止你去访问其它数据！
</span><span class="sc0">    </span><span class="sc2">//数据被损坏了的原因和影响不可能是局部的而总是全局的！
</span><span class="sc0">    </span><span class="sc11">rawbuf_reader</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">reader1</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">reader2</span><span class="sc10">-&gt;</span><span class="sc11">xx</span><span class="sc10">();</span><span class="sc0">   
    </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">reader1</span><span class="sc10">){</span><span class="sc0">
        </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"The field xx may be empty, or the data was totally corrupted!"</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc2">//To distinguish it, we need to check the reader: reader2.
</span><span class="sc0">        </span><span class="sc2">//返回值没有获得数据？可能是xx根本就没有被赋值，也可能数据xx被损坏了
</span><span class="sc0">        </span><span class="sc2">//为了区分这2种情况，我们需要再去检查reader。
</span><span class="sc0">        </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">reader2</span><span class="sc10">){</span><span class="sc0">
            </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"The data was corrupted!"</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc2">//Through reader can not visit other fields, it can get the error message.
</span><span class="sc0">            </span><span class="sc2">//尽管reader不能再用于访问数据, 他能告诉你到底检查到了什么样的错误。
</span><span class="sc0">            </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">reader2</span><span class="sc10">.</span><span class="sc11">error_msg</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"The field xx is empty"</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc5">else</span><span class="sc10">{</span><span class="sc0">
    </span><span class="sc2">//reader2-&gt;xx() does not check the fields of xx. So if we need to visit deeper for the optional fields of xx, we need to check its fields
</span><span class="sc0">    </span><span class="sc2">//reader2-&gt;xx() 不会检查xx的字段合法性，所以如果想更深入的访问xx的可选字段，需要检查对应的字段。
</span><span class="sc0">        </span><span class="sc16">int</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">x</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">reader1</span><span class="sc10">-&gt;</span><span class="sc11">x</span><span class="sc10">();</span><span class="sc0">
        </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">x</span><span class="sc10">){</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">reader1</span><span class="sc10">){</span><span class="sc0">
                </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"The data was corrupted!"</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">reader1</span><span class="sc10">.</span><span class="sc11">error_msg</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">else</span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"The field x is empty"</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc5">else</span><span class="sc10">{</span><span class="sc0">
            </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"Oh, I just get the fields x: "</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc10">*</span><span class="sc11">x</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc2">//maybe you are tired... you can take a full check for any reader, at any level
</span><span class="sc0">            </span><span class="sc2">//可能你被这样抽丝剥茧挨个检查并访问数据弄的很疲惫了是吧，，你随时可以反悔，来个以某个局部节点为树根的全量检查
</span><span class="sc0">            </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">rawbuf_has_error</span><span class="sc10">(</span><span class="sc11">reader1</span><span class="sc10">)){</span><span class="sc2">//Ok, you can visit every sub-optional fields of reader1 now.
</span><span class="sc0">                </span><span class="sc2">// For the reader, () operation also results the raw pointer
</span><span class="sc0">                </span><span class="sc11">test_type</span><span class="sc10">*</span><span class="sc0"> </span><span class="sc11">pinstance</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">reader1</span><span class="sc10">();</span><span class="sc0">
                </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">pinstance</span><span class="sc10">-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    
    </span><span class="sc2">//Now lets talk about the safely visiting the packet array via subclass of reader:rawbuf_reader_iterator
</span><span class="sc0">    </span><span class="sc2">//现在我们再来谈谈如何通过reader的子类rawbuf_reader_iterator来安全的访问包数组
</span><span class="sc0">    </span><span class="sc11">reader2</span><span class="sc10">.</span><span class="sc11">init</span><span class="sc10">(</span><span class="sc11">buffer</span><span class="sc10">,</span><span class="sc0"> </span><span class="sc11">length</span><span class="sc10">);</span><span class="sc0">
    </span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">array_count_type</span><span class="sc0"> </span><span class="sc11">psize</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc11">reader2</span><span class="sc10">-&gt;</span><span class="sc11">uu</span><span class="sc10">&lt;</span><span class="sc11">test_type1</span><span class="sc10">::</span><span class="sc11">get_count</span><span class="sc10">&gt;();</span><span class="sc0">
    </span><span class="sc5">if</span><span class="sc10">(</span><span class="sc11">psize</span><span class="sc0"> </span><span class="sc10">!=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc0"> </span><span class="sc10">){</span><span class="sc0">
        </span><span class="sc11">rawbuf_reader_iterator</span><span class="sc10">&lt;</span><span class="sc11">test_type</span><span class="sc10">&gt;</span><span class="sc0"> </span><span class="sc11">uu</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0">  </span><span class="sc11">reader2</span><span class="sc10">-&gt;</span><span class="sc11">uu</span><span class="sc10">();</span><span class="sc0"> </span><span class="sc2">//reader2-&gt;uu() does not check the fields of uu.
</span><span class="sc0">        </span><span class="sc5">for</span><span class="sc10">(</span><span class="sc11">size_t</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc0"> </span><span class="sc10">=</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc11">i</span><span class="sc10">&lt;</span><span class="sc11">psize</span><span class="sc0"> </span><span class="sc10">&amp;&amp;</span><span class="sc0"> </span><span class="sc11">uu</span><span class="sc10">;</span><span class="sc0"> </span><span class="sc10">++</span><span class="sc11">i</span><span class="sc10">,++</span><span class="sc11">uu</span><span class="sc10">){</span><span class="sc0">
            </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">rawbuf_has_error</span><span class="sc10">(</span><span class="sc11">uu</span><span class="sc10">)){</span><span class="sc0">  </span><span class="sc2">//Do a full check as following output will visit all the members.
</span><span class="sc0">                </span><span class="sc11">OUTPUT_TEST</span><span class="sc10">(</span><span class="sc11">uu</span><span class="sc10">()-&gt;</span><span class="sc11">output</span><span class="sc10">(</span><span class="sc11">std</span><span class="sc10">::</span><span class="sc11">cout</span><span class="sc10">));</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
            </span><span class="sc5">else</span><span class="sc10">{</span><span class="sc0">
                </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">uu</span><span class="sc10">-&gt;</span><span class="sc11">error_msg</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
                </span><span class="sc5">break</span><span class="sc10">;</span><span class="sc0">
            </span><span class="sc10">}</span><span class="sc0">
        </span><span class="sc10">}</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">

    </span><span class="sc5">if</span><span class="sc10">(!</span><span class="sc11">reader2</span><span class="sc10">){</span><span class="sc0">
        </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">reader2</span><span class="sc10">-&gt;</span><span class="sc11">error_msg</span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc10">}</span><span class="sc0">
    
    
    </span><span class="sc2">//During the test, if you see warning"dereferencing pointer blabla does break strict-aliasing rules", it is a bug fixed  in GCC4.4。
</span><span class="sc0">    </span><span class="sc2">//测试中如果你看到警告"dereferencing pointer blabla does break strict-aliasing rules"，请勿介意，这是一个已知的GCC4.4的bug，O2或者O3优化时会给出这个提示。
</span><span class="sc0">    </span><span class="sc2">//https://gcc.gnu.org/bugzilla/show_bug.cgi?id=39390
</span><span class="sc0">
    </span><span class="sc2">//Finally we can examine the packet size
</span><span class="sc0">    </span><span class="sc2">//最后我们看看这个包的真正大小
</span><span class="sc0">    </span><span class="sc11">cout</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc6">"size:"</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">instance2</span><span class="sc10">.</span><span class="sc11">size</span><span class="sc0"> </span><span class="sc10">()</span><span class="sc0"> </span><span class="sc10">&lt;&lt;</span><span class="sc0"> </span><span class="sc11">endl</span><span class="sc10">;</span><span class="sc0">
    </span><span class="sc2">//Till now it is 2100.
</span><span class="sc0">    </span><span class="sc5">return</span><span class="sc0"> </span><span class="sc4">0</span><span class="sc10">;</span><span class="sc0">
</span><span class="sc10">}</span><span class="sc0">
</span></div></body>
</html>
